// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// --- CORE MODELS ---

model User {
  id String @id @default(uuid())

  email          String @unique
  hashedPassword String
  name           String

  // A user can have many exam attempts
  examAttempts ExamAttempt[]
  
  // A user can have many study sessions
  studySessions StudySession[]
  
  // A user can have many notes
  notes Note[]
  
  // A user can have many study goals
  studyGoals StudyGoal[]
  
  // A user can have many flashcard decks
  flashcardDecks FlashcardDeck[]
  
  // A user can have many flashcard reviews
  flashcardReviews FlashcardReview[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Subject {
  id Int @id @default(autoincrement())

  title       String
  description String?
  sem         SemesterEnum @default(FIRST)
  isEnrolled  Boolean?     @default(true)

  // A subject can contain many tasks, files, exams, and summaries
  tasks Task[]
  files File[]
  exams Exam[] // Relation to the new Exam model
  summaries Summary[]
  studySessions StudySession[]
  notes Note[]
  studyGoals StudyGoal[]
  flashcardDecks FlashcardDeck[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
model File {
  id Int @id @default(autoincrement())

  name      String           @unique // <-- ADD THIS @unique ATTRIBUTE
  fileUrl   String
  size      Int
  type      AcceptedFileType
  embedding Unsupported("vector(1536)")?
  
  contentText String? @db.Text

  subjectId Int?
  subject   Subject? @relation(fields: [subjectId], references: [id])
  exams     Exam[]
  summaries Summary[]
  notes     Note[]
  flashcardDecks FlashcardDeck[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// --- NEW EXAM-RELATED MODELS ---

// Represents a single exam generated by the AI
model Exam {
  id Int @id @default(autoincrement())

  description    String // The instructions from the form
  requestedItems Int // The number of items requested
  status         ExamStatusEnum @default(GENERATING)
  questionTypes  QuestionTypeEnum[] // The types of questions requested
  isPracticeMode Boolean @default(false) // Practice mode allows unlimited attempts
  timeLimit      Int? // Time limit in minutes (null = no limit)

  // An exam belongs to a subject for organization
  subjectId Int
  subject   Subject @relation(fields: [subjectId], references: [id])

  // An exam is generated from one or more source files (many-to-many)
  sourceFiles File[]

  // An exam has many questions
  questions Question[]

  // An exam can be attempted multiple times
  attempts ExamAttempt[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Represents a single question within an exam
model Question {
  id Int @id @default(autoincrement())

  text          String
  type          QuestionTypeEnum @default(MULTIPLE_CHOICE)
  options       Json // e.g., ["Answer A", "Answer B", "Answer C"]
  correctAnswer String

  // A question belongs to one exam
  examId Int
  exam   Exam @relation(fields: [examId], references: [id], onDelete: Cascade)

  // This question can be answered in multiple different attempts
  userAnswers UserAnswer[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ExamAttempt {
  id Int @id @default(autoincrement())

  score       Float? // Nullable until the exam is finished
  status      AttemptStatusEnum @default(IN_PROGRESS)
  startedAt   DateTime          @default(now())
  completedAt DateTime?

  // An attempt is for a specific exam
  examId Int
  exam   Exam @relation(fields: [examId], references: [id], onDelete: Cascade)

  // An attempt is made by a specific user
  userId String
  user   User   @relation(fields: [userId], references: [id])

  // An attempt is composed of many user answers
  answers UserAnswer[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model UserAnswer {
  id Int @id @default(autoincrement())

  selectedAnswer String
  isCorrect      Boolean // Set after submission for quick scoring/review

  examAttemptId Int
  attempt       ExamAttempt @relation(fields: [examAttemptId], references: [id], onDelete: Cascade)

  questionId Int
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@unique([examAttemptId, questionId])
}



model Task {
  id          Int            @id @default(autoincrement())
  title       String
  description String
  deadline    DateTime
  status      TaskStatusEnum @default(PLANNED)
  subject     Subject?       @relation(fields: [subjectId], references: [id])
  subjectId   Int?
  notes       Note[]
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
}



enum SemesterEnum {
  FIRST
  SECOND
}

enum TaskStatusEnum {
  PLANNED
  ON_PROGRESS
  DONE
}

enum AcceptedFileType {
  PDF
  TEXT
  DOCX
}

enum ExamStatusEnum {
  GENERATING 
  READY      
  FAILED     
}

enum QuestionTypeEnum {
  MULTIPLE_CHOICE
  IDENTIFICATION
  TRUE_FALSE
}

enum AttemptStatusEnum {
  IN_PROGRESS
  COMPLETED
}

// --- SUMMARY-RELATED MODELS ---

model Summary {
  id Int @id @default(autoincrement())

  title       String
  description String // The instructions/focus from the form
  content     String? @db.Text // The generated summary content
  status      SummaryStatusEnum @default(GENERATING)
  template    SummaryTemplateEnum @default(COMPREHENSIVE)

  // A summary belongs to a subject for organization (optional)
  subjectId Int?
  subject   Subject? @relation(fields: [subjectId], references: [id])

  // A summary is generated from one or more source files (many-to-many)
  sourceFiles File[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum SummaryStatusEnum {
  GENERATING
  READY
  FAILED
}

enum SummaryTemplateEnum {
  COMPREHENSIVE
  KEY_POINTS
  CHAPTER_SUMMARY
  CONCEPT_MAP
  CUSTOM
}

// --- STUDY SESSION MODELS ---

model StudySession {
  id Int @id @default(autoincrement())

  // Session type: POMODORO, CUSTOM, or BREAK
  type SessionTypeEnum @default(POMODORO)
  
  // Duration in seconds
  duration Int // Planned duration
  actualDuration Int? // Actual duration (if completed)
  
  // Status tracking
  status SessionStatusEnum @default(IN_PROGRESS)
  
  // Optional subject association
  subjectId Int?
  subject Subject? @relation(fields: [subjectId], references: [id])
  
  // User who owns this session
  userId String
  user User @relation(fields: [userId], references: [id])
  
  // Timestamps
  startedAt DateTime @default(now())
  completedAt DateTime?
  pausedAt DateTime?
  pausedDuration Int @default(0) // Total paused time in seconds
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum SessionTypeEnum {
  POMODORO
  SHORT_BREAK
  LONG_BREAK
  CUSTOM
}

enum SessionStatusEnum {
  IN_PROGRESS
  PAUSED
  COMPLETED
  CANCELLED
}

// --- NOTE-TAKING MODELS ---

model Note {
  id Int @id @default(autoincrement())

  title       String
  content     String @db.Text // Rich text content (can be HTML or Markdown)
  isMarkdown  Boolean @default(false) // Whether content is in Markdown format
  
  // Optional relationships
  subjectId Int?
  subject   Subject? @relation(fields: [subjectId], references: [id])
  
  fileId Int?
  file   File? @relation(fields: [fileId], references: [id])
  
  taskId Int?
  task   Task? @relation(fields: [taskId], references: [id])
  
  // User who owns this note
  userId String
  user   User @relation(fields: [userId], references: [id])
  
  // Tags (many-to-many relationship)
  tags NoteTag[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Tag {
  id Int @id @default(autoincrement())

  name        String @unique
  color       String? // Optional color for UI display
  description String?
  
  // Notes with this tag
  notes NoteTag[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Join table for Note-Tag many-to-many relationship
model NoteTag {
  id Int @id @default(autoincrement())

  noteId Int
  note   Note @relation(fields: [noteId], references: [id], onDelete: Cascade)
  
  tagId Int
  tag   Tag @relation(fields: [tagId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())

  @@unique([noteId, tagId])
}

// --- FLASHCARD MODELS ---

model FlashcardDeck {
  id Int @id @default(autoincrement())

  title       String
  description String?
  
  // Optional subject association
  subjectId Int?
  subject Subject? @relation(fields: [subjectId], references: [id])
  
  // User who owns this deck
  userId String
  user User @relation(fields: [userId], references: [id])
  
  // Cards in this deck
  cards Flashcard[]
  
  // Optional source file for AI-generated decks
  sourceFileId Int?
  sourceFile File? @relation(fields: [sourceFileId], references: [id])
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Flashcard {
  id Int @id @default(autoincrement())

  // Front and back of the card
  front String @db.Text
  back String @db.Text
  
  // Optional image URLs
  frontImageUrl String?
  backImageUrl String?
  
  // Card belongs to a deck
  deckId Int
  deck FlashcardDeck @relation(fields: [deckId], references: [id], onDelete: Cascade)
  
  // Review history for spaced repetition
  reviewHistory FlashcardReview[]
  
  // Spaced repetition fields
  easeFactor Float @default(2.5) // SM-2 algorithm ease factor
  interval Int @default(0) // Days until next review
  repetitions Int @default(0) // Number of successful reviews
  lastReviewedAt DateTime?
  nextReviewAt DateTime? // When the card should be reviewed next
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model FlashcardReview {
  id Int @id @default(autoincrement())

  // Card being reviewed
  cardId Int
  card Flashcard @relation(fields: [cardId], references: [id], onDelete: Cascade)
  
  // User who reviewed
  userId String
  user User @relation(fields: [userId], references: [id])
  
  // Review quality (1-4, following SM-2 algorithm)
  // 1 = Again (hard), 2 = Hard, 3 = Good, 4 = Easy
  quality Int
  
  // Time taken to answer (in seconds)
  timeSpent Int?
  
  reviewedAt DateTime @default(now())
  
  createdAt DateTime @default(now())
}

enum GoalPeriodEnum {
  DAILY
  WEEKLY
}

// --- STUDY GOAL MODELS ---

model StudyGoal {
  id Int @id @default(autoincrement())

  // Goal type: DAILY or WEEKLY
  periodType GoalPeriodEnum @default(DAILY)
  
  // Target time in minutes (e.g., 120 = 2 hours)
  targetMinutes Int
  
  // Optional subject-specific goal
  subjectId Int?
  subject Subject? @relation(fields: [subjectId], references: [id])
  
  // User who owns this goal
  userId String
  user User @relation(fields: [userId], references: [id])
  
  // Whether the goal is currently active
  isActive Boolean @default(true)
  
  // Start date for tracking (for weekly goals, this is the week start)
  startDate DateTime @default(now())
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}